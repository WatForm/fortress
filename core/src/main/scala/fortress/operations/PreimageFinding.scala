package fortress.operations

import fortress.interpretation.Interpretation
import fortress.msfol._

/**
 * Helper functions for finding the preimage of a term.
 * The preimage of a function f given an output o is f_-1(o) = {(x1,...,xn) : f(x1,...,xn) = o}.
 * This class extends this to finding the set of values for a list of free variables that make a term
 * equal a particular value. We speed this up over brute-forcing by recognizing a few common term
 * structures generated by SMT solvers.
 */
object PreimageFinding {

    // Optimize "equals CNF": (x!1 = _@1 && x!2 = _@2) || ..., where each clause specifies values for all
    // the free variables we are interested in. The SMT solver commonly generates this for predicates.

    private def isEqualsCNF(term: Term): Boolean = term match {
        case OrList(clauses) => clauses forall {
            case AndList(atoms) => atoms forall {
                case Eq(_: Var, _: Value) | Eq(_: Value, _: Var) => true
                case _ => false
            }
            case _ => false
        }
        case _ => false
    }

    private def extractValuesFromEqualsCNF(cnf: Term): Set[Map[Var, Value]] = cnf match {
        case OrList(args) => args map { extractValuesFromEqualsCNF } reduce (_ union _)
        case AndList(args) => Set(args map {
            case Eq(variable: Var, value: Value) => Map((variable, value))
            case Eq(value: Value, variable: Var) => Map((variable, value))
        } reduce (_ ++ _))
        case e @ Eq(_, _) => extractValuesFromEqualsCNF(AndList(e))
    }

    private def findTuplesSatisfyingEqualsCNF(vars: Seq[Var], term: Term): Option[Set[Seq[Value]]] = {
        if (!isEqualsCNF(term)) {
            return None
        }

        // Ensure every clause has all the variables specified
        val valueMaps = extractValuesFromEqualsCNF(term)
        if (valueMaps exists { _.keySet != Set(vars) }) {
            // Some don't have all the variables specified, have to brute force
            return None
        }

        // Change format into a list of values corresponding to each variable in turn
        Some(valueMaps map { valueMap => vars map { v => valueMap(v) } })
    }

    // Optimize terms structured as a decision tree with ITEs. This is commonly generated for functions.

    private def isITETree(term: Term): Boolean = term match {
        case IfThenElse(Eq(_: Var, _: Value), left, right) => isITETree(left) && isITETree(right)
        case IfThenElse(Eq(_: Value, _: Var), left, right) => isITETree(left) && isITETree(right)
        case _: Value => true
        case _ => false
    }

    private def extractITETreePreimage(term: Term, output: Value): Set[Map[Var, Value]] = term match {
        case IfThenElse(Eq(variable: Var, value: Value), ifTrue, ifFalse) =>
            (extractITETreePreimage(ifTrue, output) map { _ ++ Map((variable, value)) })
            .union(extractITETreePreimage(ifFalse, output))
        case IfThenElse(Eq(value: Value, variable: Var), ifTrue, ifFalse) =>
            (extractITETreePreimage(ifTrue, output) map { _ ++ Map((variable, value)) })
              .union(extractITETreePreimage(ifFalse, output))
        case value: Value if value == output => Set(Map())
        case _ => Set()
    }

    private def getITETreePreimage(vars: Seq[Var], term: Term, output: Value): Option[Set[Seq[Value]]] = {
        if (!isITETree(term)) {
            return None
        }

        // TODO reduce duplication
        // Ensure every clause has all the variables specified
        val valueMaps = extractITETreePreimage(term, output)
        if (valueMaps exists { _.keySet != Set(vars) }) {
            // Some don't have all the variables specified, have to brute force
            return None
        }

        // Change format into a list of values corresponding to each variable in turn
        Some(valueMaps map { valueMap => vars map { v => valueMap(v) } })
    }

    // Compute the Cartesian product of a list of sequences.
    // For example, take [[a, b, c], [d, e]] to [[a, d], [a, e], [b, d], [b, e], [c, d], [c, e]].
    // Go left to right, adding each value in each sequence to all the tuples generated so far.
    private def cartesianProduct[T](seq: Seq[Seq[T]]): Seq[Seq[T]] =
        seq.foldLeft(Seq(Seq[T]())) { (tuplesSoFar, values) =>
            tuplesSoFar flatMap { tuple =>
                // Add each value to all the tuples.
                for (v <- values)
                    yield tuple :+ v
            }
        }

    private def bruteForcePreimage(interpretation: Interpretation, vars: Seq[AnnotatedVar], term: Term,
                           output: Value): Set[Seq[Value]] = {
        def evaluateTuple(tuple: Seq[Value]) = {
            val argMap = Map.from[Term, Value](vars map { _.variable } zip tuple)
            interpretation.visitFunctionBody(term, argMap)
        }

        val sortValues = vars map { annotatedVar => interpretation.sortInterpretations(annotatedVar.sort) }
        val allTuples = cartesianProduct(sortValues)
        for (tuple <- allTuples if evaluateTuple(tuple) == output)
            yield tuple
    }.toSet

    // Find the preimage of output in term, where vars are the free variables in term.
    def findPreimage(interpretation: Interpretation, vars: Seq[AnnotatedVar], term: Term,
                     output: Value): Set[Seq[Value]] = {
        // Try the special cases before resorting to brute force
        val equalsCNFOption =
          if (output == Term.mkTop) findTuplesSatisfyingEqualsCNF(vars map { _.variable }, term)
          else None

        equalsCNFOption orElse {
            getITETreePreimage(vars map { _.variable }, term, output)
        } getOrElse {
            bruteForcePreimage(interpretation, vars, term, output)
        }
    }

}
