FILES OF INTEREST
(trying to clean up changes)
- FOFTPTP.gr - antlr grammar


Look @ iflifting
Ifliftinf trnasformer
 - calls iflifting trnasformer on every axiom
 which walks over ast


 f(x) = ite (b, c, d)
ite(b, f(x) = c, f(x) = d)
..

keep going until c and d are booleans

..

(b AND f(x) = c) OR (!b AND f(x) = d)


look @ terms
and adding to the grammar - ANTLR, takes BNF
proceses the grammar

SMTLIB - std language for SMTs that we're adding to
grammar (which we're adding set cardinatlty to)


What I'm eventually going to do

setCardinalty
 - calls cardinatlity trnasformer


 sc((not())) = not(sc(x))
s(#()) = blank


 look into cases in scala


potentially set up transformer as a null operation



Questions I have while looking at the codebase - things to talk about
- theory vs problem state?
- mapBody and mapAxioms
- msfol folder - many sorted first order logic?


Things I'm getting used to (scala specific):
- scala is a functional programming language
- the way you can pass in funcitons to functions (higher order maybe??)
- map and filter
- foldr and foldl


We have our problem state - which consists of:
- theory - a collection of axioms and the language?
- scopes
- any additional information




undergrad thesis aside
- thesis course - not the same as fasttrack to masters
- reading course - introduction to formal methods

combined bachelor masters

undergrad and grad at same place is a lot of the same places and same ideas

in the us - grad school and cs is different
canada - most people do masters and then phd
in the us - a m        transformerSequence += EnumEliminationTransformer
asers is a terminal degree - basically getting a phd is like redoing a masters




negation normal form and skiloemization
- we really want to do skiloemization to get rid of quantifiers
- we need negations to do skoloemization

why ites are a problem
- ite(forall something, c, d)
- leads to forall p OR not forall p
so we do iflifting BEFORE negation normal form

for ites that sneaks through, nnf moves past it


- equivalent - rearranging the symbols basically
- equisatisfyable - rearranged and added variables where they mean the same thing

skolemization is a process that makes a problem equisatisfyable

each of our transformations aims to create an equivalent or equisatisfyable problem

SAT solvers - propositional logic solvers
- take in cnf (v) ^ (v)
- the process of going from problem to cnf is expensive
Tseitsin's encoding



What can the cardinatlity operator apply to?
In our case we need to be able to get rid of ALL the set cardinatlity
We need to limit from the user point of view


precedence between set cardinality and transitive closure

transitive closure - keep doing blank until nothing changes
ex: r;r;r;r;r;r
second order operation, because you're doing the operation on the entire operation
this is a FINITE operation


can I have a set cardinatlity of the (transitive closure of R)?
what can we take the set cardinality of

right now, cardinality is being done in portus, so it comes before transifitve closure

Nancy suspects that from a fortress scope, we'll just be dealing with cardinatlity of a predicate
- which in this case is a thing with scopes that returns true or false
- cardinality - how many arguments make that true


create a setCardinalty dummy transformer



bare bones transformers I need (/have been exposed to):
- negation normal form
- skolemization
- iflifting
- symmetry reduction
- quantifierexpansion
- transitive closure
- set cardinality

order??
- negation normal form ← brings in the negatives
- skolemization ← gets rid of all types essentially, brings things into one universe
- iflifting ← turns if then else statements into predicate logic
- symmetry reduction ← prevents state space explosion problem
- quantifierexpansion (idk if we do this or if the smt solver does)
- transitive closure ← keep doing blank until nothing changes (f;f;f;f)
- set cardinality (!!) ← turns cardinality into a bunch of ite statements

so clearly set cardinatlity has to come before iflifting

we also know that set cardinality is done in portus before, so we can act like it's done before everything (?)

(looking at other compilers) it looks like the proper order without set cardinality is:
- TypecheckSanitizeTransformer
- IfLiftingTransformer
- ClosureEliminationTransformer (there's a bunch but this is for transitive closure)
- NnfTransformer (negation normal form)
- SkolemizeTransformer
- symmetryBreakingTransformers (there's a whole bunch)
(they all also seem to end with these two, not sure what they do tho ↓)
- SimplifyTransformer
- DomainEliminationTransformer

The easy to use words are:
- typecheck
**this is where I think set cardinality should go ***
- cardinality
- iflifting
- ceeijck (again there's a bunch of options for this one but I'm picking the Eijck)
- nnf
- skolemize
- symmetry
- simplify
- domainelimination


fortress --timeout 30 -T 'typecheck' 'cardinality' 'iflifting' 'ceeijck' 'nnf' 'skolemize' 'symmetry' 'simplify' 'domainelimination' -S A=3 B=2 --generate function.smt2



A note about running and debugging and whatnot
use sbt stage and create an alias that points to ./cli/universal/whatever
--help

RIGHT NOW I AM USING THE UNCHANGED EXECUTABLE





Overarching steps:

need to add something to the parser

then the parsed thing will become a part of a term
term: SetCardinalty(t: Term)
- probably shouldnt be a boolean sort

msfol/Term.py

then write the transformer that eliminates set cardinatlity
- made up of an operation on a term and then the thing that calls a term


sbt test will run testing directory


this works now!!!!
fortress --timeout 30 -S A=3 B=2 --generate -c SetCardinality function.smt2

next steps:
implementing and understanding visitSetCardinality
actually working on the transformer


main direction: *** the direction to move for now
operation - what is the OPERATION to remove set cardinality
once we get to set cardinality we do something nice


next - how does set cardinality affect the rest of the code:
start with type checking
in some operations - doing set cardinality would be an error


Points of confusion:
- is the plus sign a part of our language? I  know and and plus are not the same but I want some sort of andlist equivalent I think
- how do I draw out the scope from the predicate?
- I think my end goal is to loop through the relevant scopes to that predicate, and feed predicate(scope variable) to ite
- How does the SetCardinality term come into play here?
- What is our base case? What am I working towards in the cases?



Our App can be of any arity, but must return a boolean
- We have to check this somewhere

Fortress does not do type inference (mostly)
there are a couple of polymorphic terms

can either check...

..when the term is constructed

or

..in typechecing pass


Term - defining the class of the node in the ast tree
Termvisitor - the plumbing

next challenge - the typechcecking

we want an App that returns a Bool

new case in the typechecking operation


cardinality eliminator (operator)
- walks over every kind of term and recurses down, recursing into arguments, until it hits a cardinality
- for most terms you do nothing
- but for cardinality you do something intersesting


What ryan does

DEFINE a function specific for a sort
FinA(a: A):= ite(inA(a), 1, 0)
^ try for apps of arity one


#(_)

whats in _? P

P: A -> bool

cardp := fp(all elements in A)

all elements in A -> enumerate

operatuion changes one axiom

every instance of cardinality with need an findp and a cardp

each cardinality makes its own function specific to that cardinality


Look at closure eliminator to see where to put function definiitons

operation will find what info you need, and ask the trasformer to make definiitons

do it with definitions!!!


look at plus and mkplus


plan:
1) typechecking
2) write some tests !!!
3) then look at operation, which walks and recurses into every term
    all you have to do is replace cardinality of arg with some name (unique!)
4) need to return some sort of request for functions
5) Then the transformer will collect the information you need for the definitions and create them
6) Then you need to take the sorts and set them to be fixed


eventually replace #(P) with card P

test in between everything! lots of unit tests